/*
  # Velocity Trend Discovery Platform - Full Schema (v2)
  # Includes "Tree & Branch" Discovery Architecture support
*/

-- 1. Core User Data
CREATE TABLE IF NOT EXISTS profiles (
  id uuid PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
  email text,
  stripe_customer_id text,
  subscription_tier text DEFAULT 'free' CHECK (subscription_tier IN ('free', 'pro', 'business')),
  created_at timestamptz DEFAULT timezone('utc'::text, now())
);

-- 2. Trend Categories (The Static List)
CREATE TABLE IF NOT EXISTS categories (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  slug text NOT NULL UNIQUE
);

-- 3. The Seeds (Broad Topics for Discovery) - NEW TABLE
-- This allows the "Tree & Branch" logic. The scraper looks here to find new trends.
CREATE TABLE IF NOT EXISTS seeds (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  term text NOT NULL UNIQUE, -- e.g., "Biohacking", "SaaS"
  category_id bigint REFERENCES categories(id) ON DELETE SET NULL,
  is_active boolean DEFAULT true, -- Turn off seeds that return garbage
  last_scraped_at timestamptz, -- For the "Low & Slow" cursor
  added_by_user_id uuid REFERENCES profiles(id) ON DELETE SET NULL, -- Identify Pro user requests
  created_at timestamptz DEFAULT now()
);

-- 4. The Trends (The "Items") - UPDATED
CREATE TABLE IF NOT EXISTS trends (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  slug text NOT NULL UNIQUE, -- Generated from name
  description text,
  category_id bigint REFERENCES categories(id) ON DELETE SET NULL,
  
  -- Updated Status to include 'discovered'
  status text DEFAULT 'discovered' CHECK (status IN ('discovered', 'regular', 'exploding', 'peaked')),
  
  -- Metrics
  current_volume int DEFAULT 0,
  growth_percentage int DEFAULT 0,
  
  -- Metadata for Scraper
  source text DEFAULT 'manual', -- 'manual', 'seed_expansion', 'user_request'
  last_fetched_at timestamptz, -- Crucial for rate-limiting cursor
  
  added_at timestamptz DEFAULT now()
);

-- 5. Historical Data Points - UPDATED
CREATE TABLE IF NOT EXISTS trend_metrics (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  trend_id bigint NOT NULL REFERENCES trends(id) ON DELETE CASCADE,
  date date NOT NULL,
  search_volume int NOT NULL DEFAULT 0,
  
  -- Prevent duplicate data for the same trend on the same day
  CONSTRAINT unique_trend_date UNIQUE (trend_id, date)
);

-- 6. User Watchlist
CREATE TABLE IF NOT EXISTS user_saved_trends (
  user_id uuid REFERENCES profiles(id) ON DELETE CASCADE,
  trend_id bigint REFERENCES trends(id) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now(),
  PRIMARY KEY (user_id, trend_id)
);

-- ==========================================
-- INDEXES (Performance & Scraper Logic)
-- ==========================================

-- Categories & Filtering
CREATE INDEX IF NOT EXISTS idx_trends_category_id ON trends(category_id);
CREATE INDEX IF NOT EXISTS idx_trends_status ON trends(status);
CREATE INDEX IF NOT EXISTS idx_trends_growth ON trends(growth_percentage DESC);

-- Scraper Cursors (CRITICAL for "Low & Slow")
-- Allows: SELECT * FROM trends ORDER BY last_fetched_at ASC LIMIT 5
CREATE INDEX IF NOT EXISTS idx_trends_last_fetched ON trends(last_fetched_at ASC NULLS FIRST);
CREATE INDEX IF NOT EXISTS idx_seeds_last_scraped ON seeds(last_scraped_at ASC NULLS FIRST);

-- Charts
CREATE INDEX IF NOT EXISTS idx_trend_metrics_trend_id ON trend_metrics(trend_id);
CREATE INDEX IF NOT EXISTS idx_trend_metrics_date ON trend_metrics(date);

-- ==========================================
-- ROW LEVEL SECURITY (RLS)
-- ==========================================

ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE seeds ENABLE ROW LEVEL SECURITY;
ALTER TABLE trends ENABLE ROW LEVEL SECURITY;
ALTER TABLE trend_metrics ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_saved_trends ENABLE ROW LEVEL SECURITY;

-- Profiles Policies
CREATE POLICY "Users can view own profile" ON profiles FOR SELECT TO authenticated USING (auth.uid() = id);
CREATE POLICY "Users can update own profile" ON profiles FOR UPDATE TO authenticated USING (auth.uid() = id);
CREATE POLICY "Users can insert own profile" ON profiles FOR INSERT TO authenticated WITH CHECK (auth.uid() = id);

-- Categories (Public Read)
CREATE POLICY "Authenticated users can view categories" ON categories FOR SELECT TO authenticated USING (true);

-- Seeds (Admin/Service Role only for write, Users can read?? Let's keep private for now)
-- The Python Scraper (Service Role) bypasses RLS, so we just need read access for debugging if needed.
CREATE POLICY "Admins can view seeds" ON seeds FOR SELECT TO authenticated USING (auth.uid() IS NOT NULL);

-- Trends (Public Read)
CREATE POLICY "Authenticated users can view trends" ON trends FOR SELECT TO authenticated USING (true);

-- Trend Metrics (Public Read)
CREATE POLICY "Authenticated users can view trend metrics" ON trend_metrics FOR SELECT TO authenticated USING (true);

-- User Saved Trends
CREATE POLICY "Users can view own saved trends" ON user_saved_trends FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can save trends" ON user_saved_trends FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can remove saved trends" ON user_saved_trends FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- ==========================================
-- UTILITIES & TRIGGERS
-- ==========================================

-- Handle new user creation automatically
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, email)
  VALUES (new.id, new.email);
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();